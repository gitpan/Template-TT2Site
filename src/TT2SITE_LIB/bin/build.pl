#!/usr/bin/perl -w
my $RCS_Id = '$Id: build.pl,v 1.3 2004/12/02 18:51:13 jv Exp $ ';

# Author          : Johan Vromans
# Created On      : Tue Mar  2 12:59:15 2004
# Last Modified By: Johan Vromans
# Last Modified On: Thu Dec  2 19:32:45 2004
# Update Count    : 24
# Status          : Unknown, Use with caution!

################ Common stuff ################

use strict;

# Package or program libraries, if appropriate.
# $LIBDIR = $ENV{'LIBDIR'} || '/usr/local/lib/sample';
# use lib qw($LIBDIR);
# require 'common.pl';

# Package name.
my $my_package = 'Sciurix';
# Program name and version.
my ($my_name, $my_version) = $RCS_Id =~ /: (.+).pl,v ([\d.]+)/;
# Tack '*' if it is not checked in into RCS.
$my_version .= '*' if length('$Locker:  $ ') > 12;

################ Command line parameters ################

use Getopt::Long 2.13 qw(:config passthrough);

# Command line options.
my $remap = 0;
my $mapfile = "lib/config/map";
my $srcdir = "src";
my $maponly = 0;
my $verbose = 0;		# verbose processing

# Development options (not shown with -help).
my $debug = 0;			# debugging
my $trace = 0;			# trace (show process)
my $test = 0;			# test mode.

# Process command line options.
app_options();

# Post-processing.
$trace |= ($debug || $test);

################ Presets ################

my $TMPDIR = $ENV{TMPDIR} || $ENV{TEMP} || '/usr/tmp';

################ The Process ################

use File::Spec;

# Find ttree.
my $ttree = "ttree";
foreach my $p ( File::Spec->path ) {
    if ( -s "$p/$ttree.pl" ) {
	$ttree = "$p/$ttree.pl";
	last;
    }
    if ( -s "$p/$ttree" && -x _ ) {
	$ttree = "$p/$ttree";
	last;
    }
}
die("Could not find ttree or ttree.pl in PATH\n")
  if $ttree eq "ttree";

use Text::ParseWords;
my $error = 0;
my $multi = 0;
my $map;

if ( $remap ) {

    my @files = glob("$srcdir/[a-z][a-z]");

    if ( ! -f ".map" && @files ) {
	foreach my $lang ( @files ) {
	    next unless -d $lang;
	    $multi++;
	    my $p = quotemeta($srcdir);
	    (my $l = $lang) =~ s;^$p/;;;
	    $map->{$l} = do_map($lang);
	}
    }
    else {
	$map = do_map($srcdir);
    }

    # use Data::Dumper;
    # print Dumper($map);

    die("Errors detected\n") if $error;

    unshift(@ARGV, "-a") if write_map();
}

unless ( $maponly ) {
    eval {
	do $ttree;
    };
    die("ttree did not complete\n$@") if $@;
}

exit 0;

################ Subroutines ################

sub do_map {
    my ($cur) = @_;
    my $map = "$cur/.map";
    my $m = {};
    unless ( -s $map && -r _ ) {
	warn("Missing: $map\n");
#	$error++;
	return $m;
    }
    warn("Process: $map\n") if $trace;

    open (my $mf, "<$map") or die("$map: $!\n");
    while ( <$mf> ) {
	chomp;
	next if /^\s*#/;
	next unless /\S/;
	my @w = shellwords($_);
	if ( $w[0] eq "title" && @w == 2 ) {
	    $m->{title} = $w[1];
	}
	elsif ( $w[0] eq "name" && @w == 2 ) {
	    $m->{name} = $w[1];
	}
	elsif ( $w[0] eq "menu" && @w == 3 ) {
	    $m->{menu} ||= [];
	    my $tag = $w[2];
	    $tag = sprintf("menu%02d", 1+scalar(@{$m->{menu}}))
	      if $tag !~ /^\w+$/;
	    push(@{$m->{menu}}, $tag);
	    if ( -d "$cur/".$w[2] ) {
		$m->{page}->{$tag} = {
				      name => $w[1],
				      %{do_map("$cur/$w[2]")},
				     };
	    }
	    elsif ( -f "$cur/$w[2].html" ) {
		$m->{page}->{$tag}->{name} = $w[1];
	    }
	    else {
		$m->{page}->{$tag}->{name} = $w[1];
		$m->{page}->{$tag}->{url} = $w[2];
	    }
	}
	else {
	    warn("Invalid entry in .map: $_\n");
	    $error++;
	}
    }
    $m;
}

sub write_map {
    my $ret = "";

    if ( $multi ) {
	for my $lang ( sort(keys(%$map)) ) {
	    $ret .= "IF site.lang == " . _str($lang) . ";\n\n";
	    $ret .= _write_map($map->{$lang}, 1);
	    $ret .= "END;\n\n";
	}
    }
    else {
	$ret .= _write_map($map, 0);
    }
    $ret .= <<EOD;
# Save in site map.
site.map = map;

IF debug;
    # Add debugging pages.
    site.map.page.debug = { name = 'Debug' };

    # Add debug item to main menu.
    site.map.menu.push('debug');
END;

# Expand map recursively.
PROCESS config/expand;

-%]
EOD

    my $content = "";
    if ( -s $mapfile ) {
	open(my $mf, "<$mapfile") || die("$mapfile: $!\n");
	local($/);
	$content = <$mf>;
	close($mf);
	$content =~ s/^(.|\n)*#### DO NOT EDIT.*\n\n//;
    }

    return 0 if $content eq $ret;

    warn("Map data changed, rewriting config/map\n");
    print STDERR ("=== old ===\n$content===new===\n$ret===\n")
      if $debug;
    open(my $mf, ">$mapfile") || die("$mapfile: $!\n");
    print $mf "[% # Generated by $my_name $my_version, ".
      localtime(time)."\n\n".
	"#### DO NOT EDIT -- CHANGES WILL GET LOST ####\n\n";
    print $mf $ret;
    close($mf);
    return 1;
}

sub _write_map {
    my ($map, $indent) = @_;
    my $ind = "  " x $indent;
    my $ret = $ind . "map = {\n";
    $ret .= __write_map($map, $indent+1);
    $ret .= $ind . "};\n\n";
    $ret;
}

sub __write_map {
    my ($map, $indent) = @_;
    my $ind = "  " x $indent;
    my $ret = "";
    $ret .= $ind . "title = " . _str($map->{title}) . "\n" if $map->{title};
    $ret .= $ind . "name = " . _str($map->{name}) . "\n" if $map->{name};
    $ret .= $ind . "url = " . _str($map->{url}) . "\n" if $map->{url};
    my $menu = $map->{menu};
    if ( $menu ) {
	$ret .= $ind . "menu = [ " .
	  join(", ", map { _str($_) } @$menu) ." ]\n";
	$ret .= $ind . "page = {\n";
	foreach my $m ( @$menu ) {
	    $ret .= $ind . "  $m = {\n";
	    $ret .= __write_map($map->{page}->{$m}, $indent+2);
	    $ret .= $ind . "  }\n";
	}
	$ret .= $ind . "}\n";
    }
    $ret;
}

sub _str {
    my ($t) = @_;
    $t =~ s/([\\\'])/\\$1/g;
    "'$t'";
}

################ Subroutines ################

sub app_options {
    my $help = 0;		# handled locally
    my $ident = 0;		# handled locally

    # Process options, if any.
    # Make sure defaults are set before returning!
    return unless @ARGV > 0;

    if ( !GetOptions(
		     'remap!'	=> \$remap,
		     'maponly'	=> \$maponly,
		     'map=s'	=> \$mapfile,
		     'srcdir=s'	=> \$srcdir,
		     'ident'	=> \$ident,
		     'verbose'	=> \$verbose,
		     'trace'	=> \$trace,
		     'help|?'	=> \$help,
		     'debug'	=> \$debug,
		    ) or $help )
    {
	app_usage(2);
    }
    app_ident() if $ident;
}

sub app_ident {
    print STDERR ("This is $my_package [$my_name $my_version]\n");
}

sub app_usage {
    my ($exit) = @_;
    app_ident();
    print STDERR <<EndOfUsage;
Usage: $0 [options] [file ...]
    -help		this message
    -ident		show identification
    -verbose		verbose information
EndOfUsage
    exit $exit if defined $exit && $exit != 0;
}
